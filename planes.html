<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>3D Driving Challenge</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/utils/BufferGeometryUtils.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Inter', sans-serif;
      background-color: #f0f0f0;
      -webkit-user-select: none;
      /* Safari */
      -ms-user-select: none;
      /* IE 10 and IE 11 */
      user-select: none;
      /* Standard syntax */
    }

    /* Prevent text selection */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* UI Elements Styling */
    #ui-container,
    #message-box,
    #difficulty-select,
    #controls-info {
      position: absolute;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      z-index: 10;
      /* Ensure UI is above canvas */
    }

    #ui-container {
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      color: white;
      text-shadow: 1px 1px 2px black;
      font-size: 1.2em;
      pointer-events: none;
      padding: 10px;
      background-color: rgba(0, 0, 0, 0.4);
    }

    #message-box,
    #difficulty-select {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 30px 50px;
      font-size: 1.8em;
      text-align: center;
    }

    #message-box {
      display: none;
      /* Hidden initially */
    }

    #difficulty-select {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }

    /* Start visible */
    #controls-info {
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #333;
      background-color: rgba(255, 255, 255, 0.7);
      padding: 5px 10px;
      font-size: 0.9em;
      display: none;
      /* Hidden initially */
    }

    /* Button Styling */
    .difficulty-button,
    #restart-button {
      margin-top: 10px;
      padding: 10px 20px;
      font-size: 0.8em;
      border: 2px solid transparent;
      /* Add border for selection highlight */
      border-radius: 8px;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s ease, border-color 0.2s ease;
      pointer-events: auto;
      min-width: 120px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .difficulty-button.easy {
      background-color: #28a745;
    }

    .difficulty-button.easy:hover {
      background-color: #218838;
    }

    .difficulty-button.medium {
      background-color: #ffc107;
      color: #333;
    }

    .difficulty-button.medium:hover {
      background-color: #e0a800;
    }

    .difficulty-button.hard {
      background-color: #dc3545;
    }

    .difficulty-button.hard:hover {
      background-color: #c82333;
    }

    /* Style for gamepad selected button */
    .difficulty-button.selected {
      border-color: #ffffff;
      /* White border */
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
      /* Glow effect */
    }


    #restart-button {
      background-color: #007bff;
    }

    #restart-button:hover {
      background-color: #0056b3;
    }

    /* Mobile Touch Controls Styling */
    #touch-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 15%;
      /* Area for controls */
      display: none;
      /* Hidden by default, shown on touch devices */
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      box-sizing: border-box;
      pointer-events: none;
      /* Allow clicks through container */
      z-index: 15;
      /* Above other UI */
    }

    .touch-button {
      background-color: rgba(80, 80, 80, 0.6);
      color: white;
      border: 2px solid rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      /* Circular buttons */
      width: 60px;
      /* Size */
      height: 60px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 1.5em;
      font-weight: bold;
      text-align: center;
      pointer-events: auto;
      /* Buttons are clickable */
      user-select: none;
      /* Prevent text selection */
      -webkit-user-select: none;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }

    .touch-button:active {
      background-color: rgba(120, 120, 120, 0.8);
    }

    #brake-button {
      margin-left: 10%;
    }

    /* Position Brake */
    #gas-button {
      margin-right: 10%;
    }

    /* Position Gas */
  </style>
</head>

<body>
  <div id="difficulty-select">
    <h2>Select Difficulty</h2>
    <button class="difficulty-button easy" data-difficulty="easy">Easy</button>
    <button class="difficulty-button medium" data-difficulty="medium">Medium</button>
    <button class="difficulty-button hard" data-difficulty="hard">Hard</button>
  </div>

  <div id="game-container" style="display: none;"></div>

  <div id="ui-container" style="display: none;">
    <div>Time Left: <span id="time">0</span>s</div>
    <div>Damage: <span id="damage">0</span>%</div>
    <div>Checkpoints: <span id="checkpoints-passed">0</span> / <span id="checkpoints-total">0</span></div>
  </div>

  <div id="message-box">
    <p id="message-text"></p>
    <button id="restart-button">Restart</button>
  </div>

  <div id="controls-info">
    Controls: Arrow Keys / Gamepad / Tilt (Mobile) / Touch
  </div>

  <div id="touch-controls">
    <div id="brake-button" class="touch-button">B</div>
    <div id="gas-button" class="touch-button">G</div>
  </div>


  <script>
    // Ensure BufferGeometryUtils is loaded
    if (typeof THREE.BufferGeometryUtils === 'undefined') {
      console.error("THREE.BufferGeometryUtils is not loaded. Make sure the script is included after three.js.");
    }

    // --- Global Variables ---
    let scene, camera, renderer;
    let car, carBody, wheels = [], house, ground, roadMesh, secondaryRoadMesh; // Added secondaryRoadMesh
    let obstacles = [], hearts = [], checkpoints = [], fences = []; // fences array holds COLLISION BOXES for ALL fences
    let keys = {}; // Keyboard state
    let raycaster; // For ground detection

    // Input State
    let gamepad = null; // Store REFERENCE to the active gamepad object (may become stale in Chrome)
    let gamepadIndex = null; // Store index of the active gamepad
    let gamepadButtons = {}; // Store current gamepad button states (read fresh each frame)
    let gamepadAxes = {}; // Store current gamepad axes states (read fresh each frame)
    let previousGamepadButtons = {}; // Store previous frame's button states
    let tiltGamma = 0; // Store device orientation gamma (left/right tilt)
    let touchGas = false; // State for touch gas button
    let touchBrake = false; // State for touch brake button
    let isTouchDevice = false; // Flag for touch device detection

    // Game State & Config
    let gameActive = false;
    let currentScreen = 'difficulty'; // 'difficulty', 'game', 'gameOver'
    let currentDifficulty = 'medium';
    let selectedDifficultyIndex = 0; // 0: Easy, 1: Medium, 2: Hard
    let timeLeft = 60;
    let timerInterval = null;
    let animationFrameId = null;
    let carHealth = 100; // Changed to 100 for percentage calculation
    let nextCheckpointIndex = 0;
    let totalCheckpoints = 0;

    // Constants
    const MAX_HEALTH = 100; // Use 100 for health
    const OBSTACLE_DAMAGE = 25; // Damage as percentage
    const HEART_REPAIR = 30; // Repair as percentage
    const CHECKPOINT_TIME_BONUS = 10;
    const ROAD_Y_OFFSET = 0.01;
    const BASE_ROAD_WIDTH = 5; // Base width unit
    const ROAD_WIDTH_MULTIPLIER = 3; // Road is 3x base width
    const ACTUAL_ROAD_WIDTH = BASE_ROAD_WIDTH * ROAD_WIDTH_MULTIPLIER;
    const SECONDARY_ROAD_WIDTH = ACTUAL_ROAD_WIDTH * 0.8; // Slightly narrower
    const FENCE_OFFSET = 0.5; // How far from the road edge the fence is placed
    const FENCE_HEIGHT = 1.5;
    const FENCE_THICKNESS = 0.2;
    const FENCE_POST_EVERY = 3; // Place a post every N meters along the road
    const OVERPASS_HEIGHT = 6; // How high the overpass goes
    const OVERPASS_START_T = 0.4; // Start overpass at 40% along the primary road's parameter t
    const OVERPASS_END_T = 0.6; // End overpass at 60% along the primary road's parameter t

    const GAMEPAD_DEADZONE = 0.15; // Deadzone for analog sticks
    const TILT_SENSITIVITY = 0.002; // Adjust for tilt steering sensitivity
    const GAMEPAD_AXIS_DEADZONE = 0.2; // Deadzone for D-pad/stick navigation
    const GAMEPAD_BUTTON_A = 0; // Standard 'confirm' button
    const GAMEPAD_BUTTON_START = 9; // Standard 'pause/start' button
    const GAMEPAD_BUTTON_DPAD_UP = 12;
    const GAMEPAD_BUTTON_DPAD_DOWN = 13;
    const GAMEPAD_BUTTON_DPAD_LEFT = 14;
    const GAMEPAD_BUTTON_DPAD_RIGHT = 15;
    const GAMEPAD_AXIS_LEFT_Y = 1; // Standard left stick Y-axis

    // Car Physics Parameters
    const baseMaxSpeed = 0.5;
    const baseAcceleration = 0.01;
    const baseBraking = 0.02;
    const baseSteeringSensitivity = 0.04;
    const friction = 0.98;
    let velocity = 0;
    let steeringAngle = 0;
    const maxSteerAngle = Math.PI / 6;
    const wheelRadius = 0.4;

    // Difficulty Settings
    const difficultySettings = {
      easy: {obstacleCount: 8, heartCount: 6, roadPoints: 5, roadVariance: 15, time: 75},
      medium: {obstacleCount: 15, heartCount: 5, roadPoints: 8, roadVariance: 25, time: 60},
      hard: {obstacleCount: 25, heartCount: 3, roadPoints: 12, roadVariance: 40, time: 50}
    };

    // DOM Elements
    const difficultySelectDiv = document.getElementById('difficulty-select');
    const difficultyButtons = document.querySelectorAll('.difficulty-button');
    const gameContainerDiv = document.getElementById('game-container');
    const uiContainerDiv = document.getElementById('ui-container');
    const messageBoxDiv = document.getElementById('message-box');
    const controlsInfoDiv = document.getElementById('controls-info');
    const timeSpan = document.getElementById('time');
    const damageSpan = document.getElementById('damage');
    const checkpointsPassedSpan = document.getElementById('checkpoints-passed');
    const checkpointsTotalSpan = document.getElementById('checkpoints-total');
    const messageTextP = document.getElementById('message-text');
    const restartButton = document.getElementById('restart-button');
    const touchControlsDiv = document.getElementById('touch-controls');
    const gasButton = document.getElementById('gas-button');
    const brakeButton = document.getElementById('brake-button');


    // --- Initialization Flow ---

    function detectTouchDevice() {
      try {
        document.createEvent("TouchEvent");
        return true;
      } catch (e) {
        return false;
      }
    }

    // Called once on window load
    function setupInitialScreen() {
      console.log("Setting up initial screen (difficulty selection).");
      currentScreen = 'difficulty';
      selectedDifficultyIndex = 0; // Default to Easy
      updateDifficultySelectionVisuals();

      difficultyButtons.forEach(button => {
        button.addEventListener('click', handleDifficultyClick);
      });
      restartButton.addEventListener('click', handleRestartClick); // For mouse click on restart

      difficultySelectDiv.style.display = 'flex';
      gameContainerDiv.style.display = 'none';
      uiContainerDiv.style.display = 'none';
      controlsInfoDiv.style.display = 'none';
      messageBoxDiv.style.display = 'none';
      touchControlsDiv.style.display = 'none'; // Ensure hidden initially

      // Start animation loop immediately to handle gamepad input on difficulty screen
      if (!animationFrameId) {
        animate();
      }
    }

    // Handles CLICKING a difficulty button
    function handleDifficultyClick(event) {
      const difficulty = event.target.getAttribute('data-difficulty');
      startSelectedGame(difficulty);
    }

    // Starts the game with the chosen difficulty
    function startSelectedGame(difficulty) {
      currentDifficulty = difficulty;
      console.log(`Difficulty selected: ${currentDifficulty}`);
      currentScreen = 'game'; // Change screen state

      difficultySelectDiv.style.display = 'none';
      gameContainerDiv.style.display = 'block';
      uiContainerDiv.style.display = 'flex';
      controlsInfoDiv.style.display = 'block';
      messageBoxDiv.style.display = 'none';

      // Show touch controls only on touch devices
      isTouchDevice = detectTouchDevice();
      if (isTouchDevice) {
        touchControlsDiv.style.display = 'flex';
        console.log("Touch device detected, showing controls.");
      } else {
        touchControlsDiv.style.display = 'none';
        console.log("Not a touch device.");
      }

      initGame(); // Initialize the actual game scene etc.
    }

    // Handles clicking the RESTART button (or pressing Start on gamepad)
    function handleRestartClick() {
      console.log("Restart triggered.");
      cleanupGame(); // Clean up the current game instance if any
      setupInitialScreen(); // Go back to difficulty selection
    }


    function initGame() {
      console.log("Initializing game...");
      try {
        // Reset state
        const settings = difficultySettings[currentDifficulty];
        timeLeft = settings.time;
        carHealth = MAX_HEALTH; // Reset health
        velocity = 0; steeringAngle = 0;
        nextCheckpointIndex = 0; totalCheckpoints = 0;
        obstacles = []; hearts = []; checkpoints = []; fences = []; // Reset fences (collision boxes)
        keys = {};
        // Don't reset gamepad/gamepadIndex here, keep connection if already established
        tiltGamma = 0; touchGas = false; touchBrake = false;
        gameActive = false; // Set to true after setup

        // Scene, Camera, Renderer
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 50, 200);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        // Clear previous canvas if exists
        while (gameContainerDiv.firstChild) {
          gameContainerDiv.removeChild(gameContainerDiv.firstChild);
        }
        gameContainerDiv.appendChild(renderer.domElement);

        // Initialize Raycaster
        raycaster = new THREE.Raycaster();

        // Lighting
        setupLighting();

        // Create Objects
        createGround();
        const primaryRoadCurve = createRoad(settings, ACTUAL_ROAD_WIDTH, 0x444444); // Returns the curve
        if (!primaryRoadCurve) throw new Error("Failed to create primary road curve.");
        createFences(primaryRoadCurve, ACTUAL_ROAD_WIDTH); // Create fences along the primary curve

        const secondaryRoadCurve = createSecondaryRoad(settings, primaryRoadCurve); // Create secondary road
        if (!secondaryRoadCurve) throw new Error("Failed to create secondary road curve.");
        createFences(secondaryRoadCurve, SECONDARY_ROAD_WIDTH); // Create fences along the secondary curve

        createCar();
        createHouse(primaryRoadCurve.getPoint(1)); // Place house at the end of primary road
        createCheckpoints(primaryRoadCurve, settings); // Checkpoints on primary road
        createObstacles(settings.obstacleCount);
        createHearts(settings.heartCount);

        // Position Car/Camera at start of primary road
        const startPoint = primaryRoadCurve.getPoint(0);
        const tangent = primaryRoadCurve.getTangent(0).normalize();
        car.position.set(startPoint.x, wheelRadius + ROAD_Y_OFFSET, startPoint.z);
        car.lookAt(startPoint.x + tangent.x, wheelRadius + ROAD_Y_OFFSET, startPoint.z + tangent.z);
        updateCameraPosition();

        // Event Listeners
        setupEventListeners();

        // Update UI
        updateTimerUI(); updateDamageUI(); updateCheckpointUI();

        // Start Game
        startTimer();
        gameActive = true; // Game is now officially active
        console.log("Game initialized successfully.");

      } catch (error) {
        console.error("Error during game initialization:", error);
        messageTextP.textContent = "Error initializing game. Please try again.";
        messageBoxDiv.style.backgroundColor = 'rgba(200, 0, 0, 0.8)';
        messageBoxDiv.style.display = 'block';
        currentScreen = 'gameOver'; // Treat error as game over
        gameActive = false;
        uiContainerDiv.style.display = 'none';
        controlsInfoDiv.style.display = 'none';
        touchControlsDiv.style.display = 'none';
      }
    }

    function setupLighting() {
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(20, 30, 10);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 1024;
      directionalLight.shadow.mapSize.height = 1024;
      directionalLight.shadow.camera.near = 0.5;
      directionalLight.shadow.camera.far = 100;
      directionalLight.shadow.camera.left = -50;
      directionalLight.shadow.camera.right = 50;
      directionalLight.shadow.camera.top = 50;
      directionalLight.shadow.camera.bottom = -50;
      scene.add(directionalLight);
    }

    // --- Object Creation Functions ---
    function createGround() {
      const groundSize = 300;
      const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
      const groundMaterial = new THREE.MeshStandardMaterial({color: 0x207020, side: THREE.DoubleSide});
      ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);
    }

    // Helper function to create road mesh geometry from a curve
    function createRoadMesh(curve, roadWidth, roadColor, roadSegments) {
      const curvePoints = curve.getPoints(roadSegments);
      const vertices = []; const normals = []; const uvs = []; const indices = [];

      for (let i = 0; i <= roadSegments; i++) {
        const t = i / roadSegments;
        const point = curvePoints[i];
        const tangent = curve.getTangentAt(t).normalize();
        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize(); // Perpendicular vector on the XZ plane

        // Calculate left and right vertices for this point
        const vL = new THREE.Vector3().copy(point).addScaledVector(normal, roadWidth / 2);
        const vR = new THREE.Vector3().copy(point).addScaledVector(normal, -roadWidth / 2);

        vertices.push(vL.x, vL.y, vL.z); // Left vertex
        vertices.push(vR.x, vR.y, vR.z); // Right vertex

        normals.push(0, 1, 0); normals.push(0, 1, 0); // Normal points straight up (approximate for curved roads)
        uvs.push(0, t); uvs.push(1, t); // UVs for texturing
      }

      // Create faces (indices)
      for (let i = 0; i < roadSegments; i++) {
        const idx1 = i * 2;       // Top left
        const idx2 = i * 2 + 1;   // Top right
        const idx3 = (i + 1) * 2; // Bottom left
        const idx4 = (i + 1) * 2 + 1; // Bottom right

        // Triangle 1: Top left, Top right, Bottom right
        indices.push(idx1, idx2, idx4);
        // Triangle 2: Top left, Bottom right, Bottom left
        indices.push(idx1, idx4, idx3);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setIndex(indices);
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
      geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
      geometry.computeVertexNormals(); // Compute normals properly for lighting on slopes

      const roadMaterial = new THREE.MeshStandardMaterial({color: roadColor, side: THREE.DoubleSide});
      const mesh = new THREE.Mesh(geometry, roadMaterial);
      mesh.receiveShadow = true; // Road can receive shadows
      mesh.castShadow = false; // Road itself doesn't cast significant shadows
      scene.add(mesh);
      return mesh; // Return the created mesh
    }

    // Creates the primary (flat) road
    function createRoad(settings, roadWidth, roadColor) {
      const roadSegments = settings.roadPoints * 10; // More segments for smoother curve

      // Generate curve points for a flat, winding road
      const points = [new THREE.Vector3(0, ROAD_Y_OFFSET, 0)];
      const roadLength = 150;
      const roadWidthVariance = 80; // Max deviation from center
      for (let i = 1; i <= settings.roadPoints; i++) {
        const z = (i / settings.roadPoints) * roadLength;
        const xVariance = (Math.random() - 0.5) * settings.roadVariance * (i / settings.roadPoints);
        const clampedX = Math.max(-roadWidthVariance / 2, Math.min(roadWidthVariance / 2, xVariance));
        points.push(new THREE.Vector3(clampedX, ROAD_Y_OFFSET, z));
      }
      if (points.length < 2) {console.error("Not enough points for road curve."); points.push(new THREE.Vector3(0, ROAD_Y_OFFSET, 10));}

      const curve = new THREE.CatmullRomCurve3(points);

      // Create road mesh geometry using helper function
      roadMesh = createRoadMesh(curve, roadWidth, roadColor, roadSegments); // Assign to global roadMesh

      return curve; // Return the curve for fence placement etc.
    }

    // Creates the secondary road with weaving and an overpass
    function createSecondaryRoad(settings, primaryCurve) {
      const roadWidth = SECONDARY_ROAD_WIDTH;
      const roadColor = 0x555555; // Darker grey
      const roadSegments = settings.roadPoints * 10; // Same segments as primary for alignment
      const baseOffset = ACTUAL_ROAD_WIDTH * 1.2; // Base distance from primary road
      const weaveFrequency = 2.5; // How many weaves along the length
      const weaveAmplitude = ACTUAL_ROAD_WIDTH * 0.8; // How far it weaves side-to-side

      const points = [];
      const minCenterlineDistance = (ACTUAL_ROAD_WIDTH / 2) + (SECONDARY_ROAD_WIDTH / 2); // Minimum distance between centerlines

      // Helper for smooth interpolation (cosine interpolation)
      function cosineInterpolate(y1, y2, mu) {
        const mu2 = (1 - Math.cos(mu * Math.PI)) / 2;
        return (y1 * (1 - mu2) + y2 * mu2);
      }

      // Calculate the offset just before and just after the overpass for interpolation
      const offsetBeforeOverpass = baseOffset + Math.sin(OVERPASS_START_T * Math.PI * weaveFrequency) * weaveAmplitude;
      const offsetAfterOverpassTarget = -baseOffset + Math.sin(OVERPASS_END_T * Math.PI * weaveFrequency) * weaveAmplitude; // Target offset on the opposite side

      // Generate points based on the primary curve
      const numPoints = settings.roadPoints * 5; // Use more points for smoother secondary curve
      for (let i = 0; i <= numPoints; i++) {
        const t = i / numPoints; // Parameter along the primary curve (0 to 1)
        const primaryPoint = primaryCurve.getPointAt(t);
        const primaryTangent = primaryCurve.getTangentAt(t).normalize();
        const primaryNormal = new THREE.Vector3(-primaryTangent.z, 0, primaryTangent.x).normalize(); // Normal on XZ plane

        let sideOffset;
        let yOffset = ROAD_Y_OFFSET;
        const isOnOverpass = (t >= OVERPASS_START_T && t <= OVERPASS_END_T);
        const overpassProgress = isOnOverpass ? (t - OVERPASS_START_T) / (OVERPASS_END_T - OVERPASS_START_T) : 0;

        if (t < OVERPASS_START_T) {
          // Before overpass: Weave on the initial side
          sideOffset = baseOffset + Math.sin(t * Math.PI * weaveFrequency) * weaveAmplitude;
          // Apply overlap prevention
          if (Math.abs(sideOffset) < minCenterlineDistance) {
            sideOffset = Math.sign(sideOffset || 1) * minCenterlineDistance;
          }
        } else if (isOnOverpass) {
          // During overpass: Interpolate horizontal offset and apply vertical offset
          sideOffset = cosineInterpolate(offsetBeforeOverpass, offsetAfterOverpassTarget, overpassProgress);
          yOffset += Math.sin(overpassProgress * Math.PI) * OVERPASS_HEIGHT;
          // No overlap prevention during the crossover itself
        } else { // t > OVERPASS_END_T
          // After overpass: Weave on the opposite side
          sideOffset = -baseOffset + Math.sin(t * Math.PI * weaveFrequency) * weaveAmplitude;
          // Apply overlap prevention (relative to the new side)
          if (Math.abs(sideOffset) < minCenterlineDistance) {
            // Ensure it stays on the negative side if adjusted
            sideOffset = Math.sign(sideOffset || -1) * minCenterlineDistance;
          }
        }

        // Calculate the point for the secondary road
        const secondaryPoint = new THREE.Vector3()
          .copy(primaryPoint)
          .addScaledVector(primaryNormal, sideOffset); // Apply calculated horizontal offset
        secondaryPoint.y = yOffset; // Apply vertical offset

        points.push(secondaryPoint);
      }

      if (points.length < 2) {console.error("Not enough points for secondary road curve."); return null;}

      const curve = new THREE.CatmullRomCurve3(points);

      // Create road mesh geometry using helper function
      secondaryRoadMesh = createRoadMesh(curve, roadWidth, roadColor, roadSegments); // Assign to global secondaryRoadMesh

      return curve; // Return the curve for fence placement
    }

    // Creates fences (visual and collision) along a given curve
    function createFences(curve, roadWidth) {
      // console.log("Creating fences..."); // Reduce console noise
      if (typeof THREE.BufferGeometryUtils === 'undefined') {
        console.error("THREE.BufferGeometryUtils is not loaded. Cannot merge fence geometries.");
        return; // Stop execution if the utility is missing
      }

      const fenceMaterial = new THREE.MeshStandardMaterial({color: 0x6b4423}); // Brownish color
      // Use slightly fewer segments for fence geometry than road for performance
      const numFenceSegments = Math.floor(curve.getLength() / (FENCE_POST_EVERY / 2));
      const curvePoints = curve.getPoints(numFenceSegments);

      const leftFenceGeometries = []; // Visual geometries
      const rightFenceGeometries = []; // Visual geometries
      // fences array is global and accumulates collision boxes from all calls

      // --- Reusable Geometry Definitions ---
      const postGeometry = new THREE.BoxGeometry(FENCE_THICKNESS * 1.5, FENCE_HEIGHT, FENCE_THICKNESS * 1.5);
      const railHeight = 0.15;
      // Define rail geometry with length 1 along Z, to be scaled later
      const baseRailGeometry = new THREE.BoxGeometry(FENCE_THICKNESS, railHeight, 1);
      // Temporary mesh for transformations
      const tempMesh = new THREE.Mesh();

      let distanceAlongCurve = 0;
      let lastPostDist = -FENCE_POST_EVERY; // Ensure first post is placed

      for (let i = 0; i < numFenceSegments; i++) {
        const t = i / numFenceSegments; // Parameter at the start of the segment
        const p1 = curvePoints[i];
        const p2 = curvePoints[i + 1] || p1; // Use p1 if it's the last point
        const segmentLength = p1.distanceTo(p2);
        if (segmentLength < 0.01) continue; // Skip zero-length segments

        // Use the midpoint and tangent for more stable orientation/positioning
        const segmentMidpoint = new THREE.Vector3().lerpVectors(p1, p2, 0.5);
        // Get tangent slightly offset into the segment for better accuracy on curves
        const tangentT = Math.min(1, t + 0.5 / numFenceSegments);
        const tangent = curve.getTangentAt(tangentT).normalize();
        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize(); // Outward normal from road center on XZ plane

        // Calculate fence line positions at the segment midpoint
        const leftFenceLinePos = new THREE.Vector3().copy(segmentMidpoint).addScaledVector(normal, roadWidth / 2 + FENCE_OFFSET);
        const rightFenceLinePos = new THREE.Vector3().copy(segmentMidpoint).addScaledVector(normal, -(roadWidth / 2 + FENCE_OFFSET));

        // --- Create Collision Geometry (Invisible Boxes per segment) ---
        const collisionFenceHeight = FENCE_HEIGHT * 1.5; // Make collision box taller
        // Collision box aligned with the tangent: Width (across road normal), Height, Length (along tangent)
        const collisionFenceGeom = new THREE.BoxGeometry(FENCE_THICKNESS * 2, collisionFenceHeight, segmentLength);
        const collisionMaterial = new THREE.MeshBasicMaterial({visible: false, transparent: true, opacity: 0}); // Invisible

        // Left Collision Fence Segment
        const leftCollisionMesh = new THREE.Mesh(collisionFenceGeom, collisionMaterial);
        leftCollisionMesh.position.copy(leftFenceLinePos); // Position at midpoint of fence line segment
        leftCollisionMesh.position.y = segmentMidpoint.y + collisionFenceHeight / 2; // Adjust Y based on road height at midpoint
        leftCollisionMesh.lookAt(leftCollisionMesh.position.clone().add(tangent)); // Align Z axis with segment direction
        leftCollisionMesh.userData.normal = normal.clone(); // Store outward normal (points away from road)
        scene.add(leftCollisionMesh);
        fences.push(leftCollisionMesh); // Add to global fences array

        // Right Collision Fence Segment
        const rightCollisionMesh = new THREE.Mesh(collisionFenceGeom.clone(), collisionMaterial);
        rightCollisionMesh.position.copy(rightFenceLinePos);
        rightCollisionMesh.position.y = segmentMidpoint.y + collisionFenceHeight / 2; // Adjust Y based on road height at midpoint
        rightCollisionMesh.lookAt(rightCollisionMesh.position.clone().add(tangent));
        rightCollisionMesh.userData.normal = normal.clone().negate(); // Store outward normal (points away from road)
        scene.add(rightCollisionMesh);
        fences.push(rightCollisionMesh); // Add to global fences array


        // --- Create Visible Geometry (Posts and Rails) ---
        const currentDistance = curve.getUtoTmapping(t, curve.getLength()); // Get distance at start of segment

        // Place Posts periodically based on distance along the curve
        if (currentDistance >= lastPostDist + FENCE_POST_EVERY) {
          const postOffsetY = FENCE_HEIGHT / 2;
          // Use the starting point of the segment (p1) for post position
          // Recalculate normal/tangent at p1 (t) for more accurate post placement
          const postTangent = curve.getTangentAt(t).normalize();
          const postNormal = new THREE.Vector3(-postTangent.z, 0, postTangent.x).normalize();
          const leftPostPos = new THREE.Vector3().copy(p1).addScaledVector(postNormal, roadWidth / 2 + FENCE_OFFSET);
          const rightPostPos = new THREE.Vector3().copy(p1).addScaledVector(postNormal, -(roadWidth / 2 + FENCE_OFFSET));

          // Left Post
          const leftPostGeom = postGeometry.clone();
          // Apply position directly, no translation needed if geometry is centered
          leftPostGeom.translate(leftPostPos.x, p1.y + postOffsetY, leftPostPos.z); // Use p1.y for post base height
          leftFenceGeometries.push(leftPostGeom);

          // Right Post
          const rightPostGeom = postGeometry.clone();
          rightPostGeom.translate(rightPostPos.x, p1.y + postOffsetY, rightPostPos.z); // Use p1.y for post base height
          rightFenceGeometries.push(rightPostGeom);

          lastPostDist = currentDistance; // Update last post distance
        }

        // Place Rails for this segment (p1 to p2)
        if (segmentLength > 0.1) { // Only add rails for segments of reasonable length
          const railRotation = Math.atan2(-tangent.x, -tangent.z); // Angle relative to negative Z-axis

          const railYPositions = [FENCE_HEIGHT * 0.3, FENCE_HEIGHT * 0.7]; // Two rails

          railYPositions.forEach(railY => {
            // --- Left Rail ---
            // Use the temporary mesh to get the world matrix
            tempMesh.geometry = baseRailGeometry; // Assign base geometry (length 1)
            tempMesh.scale.set(1, 1, segmentLength); // Scale Z to match segment length
            tempMesh.rotation.y = railRotation; // Set rotation
            // Position rail based on segment midpoint Y + rail offset Y
            tempMesh.position.set(leftFenceLinePos.x, segmentMidpoint.y + railY, leftFenceLinePos.z);
            tempMesh.updateMatrix(); // Calculate the world matrix

            // Clone the base geometry and apply the transformation
            const finalLeftRailGeom = baseRailGeometry.clone();
            finalLeftRailGeom.applyMatrix4(tempMesh.matrix);
            leftFenceGeometries.push(finalLeftRailGeom); // Add transformed geometry

            // --- Right Rail ---
            // Reuse tempMesh, just update position
            tempMesh.position.set(rightFenceLinePos.x, segmentMidpoint.y + railY, rightFenceLinePos.z);
            tempMesh.updateMatrix(); // Recalculate matrix with new position

            const finalRightRailGeom = baseRailGeometry.clone();
            finalRightRailGeom.applyMatrix4(tempMesh.matrix);
            rightFenceGeometries.push(finalRightRailGeom);
          });
        }
      }

      // --- Merge geometries for rendering performance ---
      // console.log(`Attempting to merge ${leftFenceGeometries.length} left fence geometries.`); // Reduce console noise
      if (leftFenceGeometries.length > 0) {
        try {
          const mergedLeftFenceGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(leftFenceGeometries, false);
          if (mergedLeftFenceGeometry) { // Check if merge was successful
            const leftFenceMesh = new THREE.Mesh(mergedLeftFenceGeometry, fenceMaterial);
            leftFenceMesh.castShadow = true;
            scene.add(leftFenceMesh);
            // console.log("Left fence merged successfully."); // Reduce console noise
          } else {
            console.error("mergeBufferGeometries returned null for left fence.");
          }
        } catch (error) {
          console.error("Error merging left fence geometries:", error);
        }
      }

      // console.log(`Attempting to merge ${rightFenceGeometries.length} right fence geometries.`); // Reduce console noise
      if (rightFenceGeometries.length > 0) {
        try {
          const mergedRightFenceGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(rightFenceGeometries, false);
          if (mergedRightFenceGeometry) { // Check if merge was successful
            const rightFenceMesh = new THREE.Mesh(mergedRightFenceGeometry, fenceMaterial);
            rightFenceMesh.castShadow = true;
            scene.add(rightFenceMesh);
            // console.log("Right fence merged successfully."); // Reduce console noise
          } else {
            console.error("mergeBufferGeometries returned null for right fence.");
          }
        } catch (error) {
          console.error("Error merging right fence geometries:", error);
        }
      }

      // console.log(`Fences created. ${fences.length} total collision segments.`); // Log total collision segments
    }

    function createCar() {
      car = new THREE.Group();

      const bodyGeometry = new THREE.BoxGeometry(2, 1, 4); // width, height, length
      const bodyMaterial = new THREE.MeshStandardMaterial({color: 0xff0000});
      carBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
      carBody.position.y = 0.5; // Position body relative to the group center
      carBody.castShadow = true;
      car.add(carBody);

      const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, 0.4, 24);
      wheelGeometry.rotateX(Math.PI / 2); // Rotate wheels to stand upright
      const wheelMaterial = new THREE.MeshStandardMaterial({color: 0x111111});
      const wheelPositions = [
        // Front wheels (X, Y, Z relative to car group center)
        new THREE.Vector3(1.1, 0, 1.5),  // Front right
        new THREE.Vector3(-1.1, 0, 1.5), // Front left
        // Rear wheels
        new THREE.Vector3(1.1, 0, -1.5), // Rear right
        new THREE.Vector3(-1.1, 0, -1.5) // Rear left
      ];
      wheels = [];
      wheelPositions.forEach(pos => {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        // Position wheels relative to the car group center
        wheel.position.copy(pos);
        // Ensure wheels are at the correct ground level (Y=0 within the group)
        wheel.position.y = 0;
        wheel.castShadow = true;
        car.add(wheel);
        wheels.push(wheel);
      });
      // Set the entire car group's position in the scene
      // This will be done in initGame based on the road start
      scene.add(car);
      // console.log("Car created."); // Reduce console noise
    }
    function createHouse(position) {
      house = new THREE.Group();
      const baseGeometry = new THREE.BoxGeometry(6, 4, 5);
      const baseMaterial = new THREE.MeshStandardMaterial({color: 0x8B4513}); // Brown
      const base = new THREE.Mesh(baseGeometry, baseMaterial);
      base.position.y = 2; // Center of base at y=2
      base.castShadow = true; base.receiveShadow = true;
      house.add(base);
      const roofGeometry = new THREE.ConeGeometry(5, 2, 4); // radius, height, segments
      const roofMaterial = new THREE.MeshStandardMaterial({color: 0xA52A2A}); // Reddish brown
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.y = 4 + 1; // Position roof on top of base (base height/2 + roof height/2)
      roof.rotation.y = Math.PI / 4; // Rotate roof for pyramid look
      roof.castShadow = true;
      house.add(roof);
      // Position the entire house group
      house.position.set(position.x, 0, position.z); // Set ground position
      scene.add(house);
      // console.log("House created at", house.position); // Reduce console noise
    }
    function createCheckpoints(curve, settings) {
      checkpoints = [];
      const numCheckpoints = Math.max(1, Math.floor(settings.roadPoints / 2));
      totalCheckpoints = numCheckpoints;
      // console.log(`Creating ${totalCheckpoints} checkpoints.`); // Reduce console noise

      const checkpointRadius = 8; // Outer radius of the torus
      const checkpointTube = 0.6; // Radius of the tube itself
      const checkpointGeometry = new THREE.TorusGeometry(checkpointRadius, checkpointTube, 8, 30); // Low segments for performance
      const checkpointMaterial = new THREE.MeshStandardMaterial({
        color: 0x00ffff, // Cyan
        transparent: true,
        opacity: 0.7,
        side: THREE.DoubleSide // Render both sides
      });

      for (let i = 1; i <= numCheckpoints; i++) {
        const t = i / (numCheckpoints + 1); // Distribute checkpoints along the curve (excluding start/end)
        try {
          const point = curve.getPointAt(t);
          const tangent = curve.getTangentAt(t).normalize();

          const checkpoint = new THREE.Mesh(checkpointGeometry, checkpointMaterial.clone()); // Clone material

          // Position the checkpoint above the road
          checkpoint.position.set(point.x, point.y + checkpointRadius * 0.75, point.z); // Raise slightly

          // Orient the checkpoint to face along the road tangent
          const up = new THREE.Vector3(0, 1, 0);
          checkpoint.quaternion.setFromUnitVectors(up, tangent); // Align default up (Y) with tangent
          checkpoint.rotateX(Math.PI / 2); // Rotate torus to be upright relative to road

          checkpoint.userData = {index: i - 1, active: true}; // Store index and state
          checkpoint.castShadow = false; // Checkpoints don't cast shadows
          scene.add(checkpoint);
          checkpoints.push(checkpoint);
        } catch (error) {console.error(`Error creating checkpoint ${i} at t=${t}:`, error);}
      }
      updateCheckpointUI();
    }
    function createObstacles(count) {
      obstacles = [];
      const obstacleGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
      const obstacleMaterial = new THREE.MeshStandardMaterial({color: 0x808080}); // Grey
      for (let i = 0; i < count; i++) {
        const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
        // Place obstacles somewhat near the road area
        const x = (Math.random() - 0.5) * 50; // Reduced spread compared to ground size
        const z = Math.random() * 120 + 20; // Place ahead of the start
        obstacle.position.set(x, 0.75, z); // Position on the ground (geometry height/2)
        obstacle.castShadow = true; obstacle.receiveShadow = true;
        scene.add(obstacle); obstacles.push(obstacle);
      }
      // console.log(`Created ${count} obstacles.`); // Reduce console noise
    }
    function createHearts(count) {
      hearts = [];
      // Create heart shape
      const heartShape = new THREE.Shape();
      const x = 0, y = 0;
      heartShape.moveTo(x + 0.25, y + 0.25);
      heartShape.bezierCurveTo(x + 0.25, y + 0.25, x + 0.2, y, x, y);
      heartShape.bezierCurveTo(x - 0.3, y, x - 0.3, y + 0.35, x - 0.3, y + 0.35);
      heartShape.bezierCurveTo(x - 0.3, y + 0.55, x - 0.1, y + 0.77, x + 0.25, y + 0.95);
      heartShape.bezierCurveTo(x + 0.6, y + 0.77, x + 0.8, y + 0.55, x + 0.8, y + 0.35);
      heartShape.bezierCurveTo(x + 0.8, y + 0.35, x + 0.8, y, x + 0.5, y);
      heartShape.bezierCurveTo(x + 0.35, y, x + 0.25, y + 0.25, x + 0.25, y + 0.25);

      const extrudeSettings = {depth: 0.1, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelOffset: 0, bevelSegments: 1};
      const heartGeometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
      heartGeometry.center(); // Center the geometry
      heartGeometry.rotateX(Math.PI); // Rotate to face up
      heartGeometry.scale(0.8, 0.8, 0.8); // Scale it down a bit

      const heartMaterial = new THREE.MeshStandardMaterial({color: 0xff69b4, emissive: 0x550000}); // Pinkish with slight glow

      for (let i = 0; i < count; i++) {
        const heart = new THREE.Mesh(heartGeometry, heartMaterial);
        // Place hearts somewhat near the road
        const hx = (Math.random() - 0.5) * 40; // Reduced spread
        const hz = Math.random() * 100 + 25; // Place ahead of start
        heart.position.set(hx, 0.7, hz); // Position slightly above ground
        heart.castShadow = true;
        heart.userData.rotationSpeed = (Math.random() - 0.5) * 0.02; // Random rotation speed
        scene.add(heart); hearts.push(heart);
      }
      // console.log(`Created ${count} hearts.`); // Reduce console noise
    }

    // --- Event Listeners ---
    function setupEventListeners() {
      // Remove previous listeners to avoid duplicates
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      window.removeEventListener('resize', onWindowResize);
      window.removeEventListener('deviceorientation', handleDeviceOrientation);
      window.removeEventListener('gamepadconnected', handleGamepadConnect);
      window.removeEventListener('gamepaddisconnected', handleGamepadDisconnect);
      gasButton.removeEventListener('touchstart', handleGasTouchStart);
      gasButton.removeEventListener('touchend', handleGasTouchEnd);
      gasButton.removeEventListener('touchcancel', handleGasTouchEnd);
      brakeButton.removeEventListener('touchstart', handleBrakeTouchStart);
      brakeButton.removeEventListener('touchend', handleBrakeTouchEnd);
      brakeButton.removeEventListener('touchcancel', handleBrakeTouchEnd);


      // Add new listeners
      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      window.addEventListener('resize', onWindowResize);

      // Gamepad listeners (always active)
      window.addEventListener('gamepadconnected', handleGamepadConnect);
      window.addEventListener('gamepaddisconnected', handleGamepadDisconnect);

      // Device Orientation listener (only if touch device)
      if (isTouchDevice) {
        window.addEventListener('deviceorientation', handleDeviceOrientation, true); // Use capture phase
        // Touch button listeners
        gasButton.addEventListener('touchstart', handleGasTouchStart, {passive: false});
        gasButton.addEventListener('touchend', handleGasTouchEnd, {passive: false});
        gasButton.addEventListener('touchcancel', handleGasTouchEnd, {passive: false});
        brakeButton.addEventListener('touchstart', handleBrakeTouchStart, {passive: false});
        brakeButton.addEventListener('touchend', handleBrakeTouchEnd, {passive: false});
        brakeButton.addEventListener('touchcancel', handleBrakeTouchEnd, {passive: false});
      }

      // console.log("Event listeners setup."); // Reduce console noise
    }

    // Input Handlers
    function handleKeyDown(event) {keys[event.code] = true;}
    function handleKeyUp(event) {keys[event.code] = false;}
    function onWindowResize() {
      if (!camera || !renderer) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      // console.log("Window resized."); // Reduce console noise
    }
    function handleDeviceOrientation(event) {
      if (event.gamma !== null) {
        tiltGamma = event.gamma; // Store gamma value (-90 to 90)
      }
    }
    function handleGamepadConnect(event) {
      console.log('Gamepad connected:', event.gamepad.id, 'Index:', event.gamepad.index);
      // Only take the first connected gamepad for simplicity
      if (gamepadIndex === null) {
        gamepad = event.gamepad; // Store reference (might be stale later)
        gamepadIndex = event.gamepad.index; // Store the index
        gamepadButtons = {}; gamepadAxes = {}; previousGamepadButtons = {}; // Reset states
      }
    }
    function handleGamepadDisconnect(event) {
      console.log('Gamepad disconnected:', event.gamepad.id, 'Index:', event.gamepad.index);
      // If the disconnected gamepad is the one we are using
      if (gamepadIndex === event.gamepad.index) {
        gamepad = null;
        gamepadIndex = null;
        gamepadButtons = {}; gamepadAxes = {}; previousGamepadButtons = {};
      }
    }
    function handleGasTouchStart(event) {event.preventDefault(); touchGas = true;}
    function handleGasTouchEnd(event) {event.preventDefault(); touchGas = false;}
    function handleBrakeTouchStart(event) {event.preventDefault(); touchBrake = true;}
    function handleBrakeTouchEnd(event) {event.preventDefault(); touchBrake = false;}

    // --- Gamepad State Update ---
    function updateGamepadState() {
      // Always poll for the latest gamepad states
      const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];

      // Find the currently active gamepad using its stored index
      let latestGamepadState = null;
      if (gamepadIndex !== null && gamepads[gamepadIndex]) {
        latestGamepadState = gamepads[gamepadIndex];
      } else if (gamepadIndex !== null) {
        // The gamepad at our stored index is gone, handle disconnect
        console.log('Gamepad at index', gamepadIndex, 'seems disconnected during poll.');
        handleGamepadDisconnect({gamepad: {index: gamepadIndex, id: "Unknown (disconnected)"}}); // Simulate disconnect
        return; // Stop processing for this frame
      } else {
        // We don't have an active gamepad index, try to find the first connected one
        for (let i = 0; i < gamepads.length; i++) {
          if (gamepads[i]) {
            console.log('Found new gamepad during poll, connecting...');
            handleGamepadConnect({gamepad: gamepads[i]}); // Connect to the first one found
            latestGamepadState = gamepads[i]; // Use this one for the current frame
            break;
          }
        }
      }

      // If no gamepad is active after polling, clear states and exit
      if (!latestGamepadState) {
        gamepadButtons = {};
        gamepadAxes = {};
        return;
      }

      // --- Read fresh state from the latestGamepadState ---
      previousGamepadButtons = {...gamepadButtons}; // Store previous state

      // Update current state using the LATEST object's data
      gamepadButtons = {};
      latestGamepadState.buttons.forEach((button, index) => {
        gamepadButtons[index] = button.pressed;
      });
      gamepadAxes = {};
      latestGamepadState.axes.forEach((axis, index) => {
        // Apply deadzone directly here for simplicity
        gamepadAxes[index] = Math.abs(axis) > GAMEPAD_DEADZONE ? axis : 0;
      });
    }


    // Helper to check if a button was just pressed this frame
    function wasButtonPressed(buttonIndex) {
      // Check if the button exists in the current state before accessing
      return gamepadButtons.hasOwnProperty(buttonIndex) && gamepadButtons[buttonIndex] &&
        (!previousGamepadButtons.hasOwnProperty(buttonIndex) || !previousGamepadButtons[buttonIndex]);
    }

    // --- Game Logic ---

    // Handles input specifically for the difficulty selection screen
    function processDifficultyInput() {
      // Check if a gamepad is connected (via gamepadIndex)
      if (gamepadIndex === null) return;

      let moved = false;
      // Use the globally updated gamepadAxes/Buttons which are fresh
      const stickY = gamepadAxes[GAMEPAD_AXIS_LEFT_Y] || 0;
      const prevStickY = previousGamepadAxes[GAMEPAD_AXIS_LEFT_Y] || 0;

      // D-pad Up / Left Stick Up (Check for transition past deadzone)
      // Use GAMEPAD_AXIS_DEADZONE for menu navigation consistency
      if (wasButtonPressed(GAMEPAD_BUTTON_DPAD_UP) || (stickY < -GAMEPAD_AXIS_DEADZONE && prevStickY >= -GAMEPAD_AXIS_DEADZONE)) {
        selectedDifficultyIndex = (selectedDifficultyIndex - 1 + difficultyButtons.length) % difficultyButtons.length;
        moved = true;
      }
      // D-pad Down / Left Stick Down (Check for transition past deadzone)
      else if (wasButtonPressed(GAMEPAD_BUTTON_DPAD_DOWN) || (stickY > GAMEPAD_AXIS_DEADZONE && prevStickY <= GAMEPAD_AXIS_DEADZONE)) {
        selectedDifficultyIndex = (selectedDifficultyIndex + 1) % difficultyButtons.length;
        moved = true;
      }

      if (moved) {
        updateDifficultySelectionVisuals();
      }

      // Select Button (A)
      if (wasButtonPressed(GAMEPAD_BUTTON_A)) {
        const selectedButton = difficultyButtons[selectedDifficultyIndex];
        if (selectedButton) {
          const difficulty = selectedButton.getAttribute('data-difficulty');
          startSelectedGame(difficulty);
        }
      }
    }

    // Updates which difficulty button has the 'selected' class
    function updateDifficultySelectionVisuals() {
      difficultyButtons.forEach((button, index) => {
        button.classList.toggle('selected', index === selectedDifficultyIndex);
      });
    }


    // Processes input during active gameplay
    function processGameplayInput() {
      let steerInput = 0;
      let accelInput = 0;
      let brakeInput = 0;

      // 1. Gamepad Input (Highest Priority - use globally updated states)
      if (gamepadIndex !== null) {
        const stickX = gamepadAxes[0] || 0; // Already has deadzone applied in updateGamepadState
        if (stickX !== 0) { // Check if outside deadzone
          steerInput = -stickX;
        } else {
          if (gamepadButtons[GAMEPAD_BUTTON_DPAD_LEFT]) steerInput = 1.0;
          if (gamepadButtons[GAMEPAD_BUTTON_DPAD_RIGHT]) steerInput = -1.0;
        }

        // Read trigger values directly from the LATEST state if available
        // The global gamepad reference might be stale, but axes/buttons are updated
        const currentPadState = navigator.getGamepads()[gamepadIndex];
        if (currentPadState) {
          const rightTrigger = currentPadState.buttons[7]; // RT
          if (rightTrigger) accelInput = rightTrigger.value;
          const leftTrigger = currentPadState.buttons[6]; // LT
          if (leftTrigger) brakeInput = leftTrigger.value;
        }


        // Restart Button (Start)
        if (wasButtonPressed(GAMEPAD_BUTTON_START)) {
          handleRestartClick();
          return null; // Stop further processing
        }
      }

      // 2. Tilt Input (If no gamepad steering, and on touch device)
      if (steerInput === 0 && isTouchDevice && tiltGamma !== 0) {
        const clampedGamma = Math.max(-45, Math.min(45, tiltGamma));
        steerInput = -(clampedGamma / 45.0);
      }

      // 3. Touch Button Input (If no gamepad accel/brake, and on touch device)
      if (accelInput < 0.1 && brakeInput < 0.1 && isTouchDevice) {
        if (touchGas) accelInput = 1.0;
        if (touchBrake) brakeInput = 1.0;
      }


      // 4. Keyboard Input (Lowest Priority)
      if (steerInput === 0) {
        if (keys['ArrowLeft'] || keys['KeyA']) steerInput = 1.0;
        if (keys['ArrowRight'] || keys['KeyD']) steerInput = -1.0;
      }
      if (accelInput < 0.1 && brakeInput < 0.1) {
        if (keys['ArrowUp'] || keys['KeyW']) accelInput = 1.0;
        if (keys['ArrowDown'] || keys['KeyS']) brakeInput = 1.0;
      }

      return {steer: steerInput, accel: accelInput, brake: brakeInput};
    }

    // Processes input on the Game Over screen
    function processGameOverInput() {
      // Check if a gamepad is connected (via gamepadIndex)
      if (gamepadIndex === null) return;
      // Restart Button (Start or A)
      if (wasButtonPressed(GAMEPAD_BUTTON_START) || wasButtonPressed(GAMEPAD_BUTTON_A)) {
        handleRestartClick();
      }
    }


    function updateCarMovement() {
      if (!gameActive || !car || !raycaster) return; // Added raycaster check

      const input = processGameplayInput();
      if (!input) return; // Input handler might return null if restarting

      // Performance based on damage
      const healthFactor = Math.max(0.1, carHealth / MAX_HEALTH);
      const currentMaxSpeed = baseMaxSpeed * (0.5 + healthFactor * 0.5);
      const currentAcceleration = baseAcceleration * (0.3 + healthFactor * 0.7);
      const currentSteeringSensitivity = baseSteeringSensitivity;
      const currentBraking = baseBraking * (0.5 + healthFactor * 0.5);

      // Apply acceleration/braking
      velocity += input.accel * currentAcceleration;
      velocity -= input.brake * currentBraking;

      // Apply friction
      velocity *= friction;

      // Clamp velocity
      velocity = Math.max(-currentMaxSpeed / 2, Math.min(currentMaxSpeed, velocity));

      // Apply steering smoothly
      const targetSteeringAngle = input.steer * maxSteerAngle;
      steeringAngle += (targetSteeringAngle - steeringAngle) * 0.3; // Interpolation factor

      // Update Car Rotation (Yaw) only if moving significantly
      if (Math.abs(velocity) > 0.01) {
        const turnRate = steeringAngle * Math.sign(velocity) * 0.05; // Adjust multiplier for sensitivity
        car.rotation.y += turnRate;
      }

      // Update Position based on forward vector
      const forward = new THREE.Vector3(0, 0, 1).applyQuaternion(car.quaternion);
      car.position.addScaledVector(forward, velocity);

      // --- Determine Ground Height using Raycasting ---
      const rayOrigin = new THREE.Vector3(car.position.x, car.position.y + 5, car.position.z); // Start ray above car
      const rayDirection = new THREE.Vector3(0, -1, 0); // Point down
      raycaster.set(rayOrigin, rayDirection);

      const roadMeshes = [];
      if (roadMesh) roadMeshes.push(roadMesh);
      if (secondaryRoadMesh) roadMeshes.push(secondaryRoadMesh);

      let groundY = ROAD_Y_OFFSET; // Default ground height

      if (roadMeshes.length > 0) {
        const intersects = raycaster.intersectObjects(roadMeshes);

        if (intersects.length > 0) {
          // Find the highest intersection point (important for overpasses)
          let highestPointY = -Infinity;
          intersects.forEach(intersect => {
            if (intersect.point.y > highestPointY) {
              highestPointY = intersect.point.y;
            }
          });
          groundY = highestPointY; // Set ground height to the highest point found
        }
      }

      // Set car's Y position based on detected ground height + wheel radius
      car.position.y = groundY + wheelRadius;
      // --- End Ground Height Determination ---

      // Wheel rotation
      const wheelRotation = velocity / wheelRadius;
      wheels.forEach((wheel, index) => {
        wheel.rotation.z -= wheelRotation; // Forward/backward rotation (around Z in local space)
        // Apply steering rotation smoothly to front wheels (around Y in local space)
        if (index < 2) { // Front wheels
          wheel.rotation.y += (steeringAngle - wheel.rotation.y) * 0.4;
        } else { // Rear wheels straighten out
          wheel.rotation.y *= 0.9;
        }
      });

      updateCameraPosition();
    }

    function updateCameraPosition() {
      if (!camera || !car) return; // Check if camera exists
      const offset = new THREE.Vector3(0, 6, -14); // Camera distance and height
      offset.applyQuaternion(car.quaternion); // Apply car's rotation to offset
      camera.position.copy(car.position).add(offset);

      // Look slightly ahead of the car
      const lookAtOffset = new THREE.Vector3(0, 2.0, 5.0); // Look ahead distance
      lookAtOffset.applyQuaternion(car.quaternion);
      const lookAtPos = new THREE.Vector3().copy(car.position).add(lookAtOffset);

      camera.lookAt(lookAtPos);
    }

    function checkCollisions() {
      if (!gameActive || !car || !carBody) return;

      // Update car's world matrix if needed (important for accurate Box3)
      car.updateMatrixWorld();
      // Create Box3 from the carBody mesh in world space
      const carBox = new THREE.Box3().setFromObject(carBody, true); // Use true for precise calculation

      // House collision (End Goal)
      if (house) {
        const houseBox = new THREE.Box3().setFromObject(house);
        if (carBox.intersectsBox(houseBox)) {
          if (nextCheckpointIndex === totalCheckpoints) {
            endGame(true); // Win condition
          }
        }
      }

      // Checkpoint collision
      if (checkpoints && nextCheckpointIndex < checkpoints.length) {
        const targetCheckpoint = checkpoints[nextCheckpointIndex];
        if (targetCheckpoint && targetCheckpoint.userData.active) {
          const distanceToCheckpoint = car.position.distanceTo(targetCheckpoint.position);
          if (distanceToCheckpoint < (targetCheckpoint.geometry.parameters.radius + 1.5)) {
            hitCheckpoint(targetCheckpoint);
          }
        }
      }

      // Obstacle collision
      obstacles.forEach(obstacle => {
        if (!obstacle.parent) return; // Skip if already removed
        const obstacleBox = new THREE.Box3().setFromObject(obstacle);
        if (carBox.intersectsBox(obstacleBox)) {
          takeDamage(OBSTACLE_DAMAGE);
          // Bounce effect
          velocity *= -0.3; // Bounce back
          const direction = new THREE.Vector3().subVectors(car.position, obstacle.position).normalize();
          direction.y = 0; // Keep bounce horizontal
          car.position.addScaledVector(direction, 0.5); // Push car back slightly
        }
      });

      // Fence collision (Checks all fence segments from both roads)
      fences.forEach(fenceSegment => {
        if (!fenceSegment.parent) return; // Skip removed/invisible segments
        // Update fence segment's world matrix (important for Box3)
        fenceSegment.updateMatrixWorld();
        const fenceBox = new THREE.Box3().setFromObject(fenceSegment, true); // Precise box

        if (carBox.intersectsBox(fenceBox)) {
          // console.log("Fence collision!"); // Reduce console spam
          velocity = 0; // Stop the car immediately

          // Push the car slightly back TOWARDS the road (opposite of the fence normal)
          const pushDirection = fenceSegment.userData.normal.clone().negate(); // <-- Negate the normal here!
          pushDirection.y = 0; // Ensure push is horizontal
          pushDirection.normalize();

          car.position.addScaledVector(pushDirection, 0.1); // Push in the negated (inward) direction

          // Optional: Dampen steering to prevent sticking
          // steeringAngle *= 0.5;
        }
      });


      // Heart collision
      hearts.slice().forEach((heart) => { // Use slice for safe removal
        if (!heart.parent) return;
        const heartBox = new THREE.Box3().setFromObject(heart);
        heartBox.expandByScalar(0.3); // Make hitbox slightly larger
        if (carBox.intersectsBox(heartBox)) {
          collectHeart(heart);
        }
      });
    }

    function hitCheckpoint(checkpoint) {
      if (!gameActive || !checkpoint || !checkpoint.userData.active) return;
      // console.log(`Checkpoint ${checkpoint.userData.index + 1} hit!`); // Reduce console noise
      checkpoint.userData.active = false;
      checkpoint.material.color.setHex(0x00ff00); // Green
      checkpoint.material.opacity = 0.3;

      nextCheckpointIndex++;
      timeLeft += CHECKPOINT_TIME_BONUS;
      updateCheckpointUI();
      updateTimerUI();

      if (nextCheckpointIndex === totalCheckpoints) {
        console.log("All checkpoints passed! Head to the house!");
      }
    }

    function takeDamage(amount) {
      if (!gameActive) return;
      carHealth -= amount;
      carHealth = Math.max(0, carHealth); // Clamp at 0
      // console.log(`Damage taken, health: ${carHealth}`); // Reduce console noise
      updateDamageUI(); // Updates UI and car color

      // Visual feedback: Flash effect
      if (carBody && carBody.material) {
        carBody.material.color.setHex(0xffffff); // Flash white
        carBody.material.emissive.setHex(0x555555); // Glow
        setTimeout(() => {
          if (carBody && carBody.material) {
            updateDamageUI(); // Restore color based on health
            carBody.material.emissive.setHex(0x000000); // Turn off glow
          }
        }, 150); // Flash duration
      }

      if (carHealth <= 0) {
        endGame(false, "Your car is too damaged!");
      }
    }

    function collectHeart(heart) {
      if (!gameActive || !heart || !heart.parent) return;
      carHealth += HEART_REPAIR;
      carHealth = Math.min(MAX_HEALTH, carHealth); // Clamp at max health
      // console.log(`Heart collected, health: ${carHealth}`); // Reduce console noise
      updateDamageUI(); // Update UI and car color

      scene.remove(heart);
      const index = hearts.indexOf(heart);
      if (index > -1) hearts.splice(index, 1);
    }

    // --- UI Update Functions ---
    function startTimer() {
      clearInterval(timerInterval); // Clear any existing timer
      timerInterval = setInterval(() => {
        if (!gameActive) {clearInterval(timerInterval); return;}
        timeLeft--;
        updateTimerUI();
        if (timeLeft <= 0) {
          timeLeft = 0; updateTimerUI();
          endGame(false, "Time's up!");
        }
      }, 1000);
    }
    function updateTimerUI() {timeSpan.textContent = Math.max(0, timeLeft);}
    function updateDamageUI() {
      const damagePercent = Math.max(0, 100 - carHealth);
      damageSpan.textContent = `${damagePercent.toFixed(0)}%`;

      if (carBody && carBody.material) {
        const healthRatio = carHealth / MAX_HEALTH;
        const red = 1.0;
        const greenBlue = healthRatio * 0.8; // Less green/blue when damaged
        carBody.material.color.setRGB(red, greenBlue, greenBlue);
        carBody.userData.originalColor = carBody.material.color.getHex();
      }
    }
    function updateCheckpointUI() {
      checkpointsPassedSpan.textContent = nextCheckpointIndex;
      checkpointsTotalSpan.textContent = totalCheckpoints;
    }

    // --- Game End and Cleanup ---
    function endGame(isWin, message = "") {
      if (!gameActive && currentScreen === 'gameOver') return; // Prevent multiple calls

      console.log(`Game ended. Win: ${isWin}, Message: ${message}`);
      gameActive = false; // Stop game logic updates
      currentScreen = 'gameOver'; // Set screen state
      clearInterval(timerInterval); timerInterval = null;
      velocity = 0; // Stop car movement

      if (isWin) {
        messageTextP.textContent = "You reached the house! YOU WIN!";
        messageBoxDiv.style.backgroundColor = 'rgba(0, 150, 0, 0.8)'; // Green
      } else {
        if (!message && carHealth <= 0) message = "Car destroyed!";
        else if (!message && timeLeft <= 0) message = "Time's up!";
        else if (!message) message = "Try again!";
        messageTextP.textContent = `GAME OVER! ${message}`;
        messageBoxDiv.style.backgroundColor = 'rgba(150, 0, 0, 0.8)'; // Red
      }
      messageBoxDiv.style.display = 'block'; // Show message box

      // Hide in-game UI
      uiContainerDiv.style.display = 'none';
      controlsInfoDiv.style.display = 'none';
      touchControlsDiv.style.display = 'none';
    }

    function cleanupGame() {
      console.log("Cleaning up previous game instance...");
      gameActive = false;

      if (timerInterval) {clearInterval(timerInterval); timerInterval = null;}

      // Remove specific listeners
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      window.removeEventListener('deviceorientation', handleDeviceOrientation, true);
      gasButton.removeEventListener('touchstart', handleGasTouchStart);
      gasButton.removeEventListener('touchend', handleGasTouchEnd);
      gasButton.removeEventListener('touchcancel', handleGasTouchEnd);
      brakeButton.removeEventListener('touchstart', handleBrakeTouchStart);
      brakeButton.removeEventListener('touchend', handleBrakeTouchEnd);
      brakeButton.removeEventListener('touchcancel', handleBrakeTouchEnd);


      if (scene) {
        // Dispose of geometries, materials, textures
        const objectsToRemove = [];
        scene.traverse(object => {
          objectsToRemove.push(object); // Collect all objects
          if (object.isMesh) {
            if (object.geometry) object.geometry.dispose();
            if (object.material) {
              // Dispose materials and textures
              const materials = Array.isArray(object.material) ? object.material : [object.material];
              materials.forEach(material => {
                Object.keys(material).forEach(key => {
                  const value = material[key];
                  if (value && typeof value === 'object' && typeof value.dispose === 'function') {
                    value.dispose();
                  }
                });
                material.dispose();
              });
            }
          }
        });
        // Remove objects from scene starting from children
        objectsToRemove.reverse().forEach(object => {
          if (object.parent) {
            object.parent.remove(object);
          }
        });
        // console.log("Scene objects disposed and removed."); // Reduce console noise
      }
      if (renderer) {
        renderer.dispose(); // Dispose WebGL context
        if (renderer.domElement.parentNode) {
          renderer.domElement.parentNode.removeChild(renderer.domElement); // Remove canvas
        }
        renderer = null;
        // console.log("Renderer disposed and canvas removed."); // Reduce console noise
      }

      // Clear references
      scene = null; camera = null; car = null; carBody = null; house = null;
      ground = null; roadMesh = null; secondaryRoadMesh = null; // Clear secondary road mesh
      wheels = []; obstacles = []; hearts = []; checkpoints = []; fences = []; // Clear fences
      keys = {}; tiltGamma = 0; touchGas = false; touchBrake = false;
      raycaster = null; // Clear raycaster

      console.log("Cleanup complete.");
    }

    // --- Animation Loop (Handles all states) ---
    let previousGamepadAxes = {}; // Track previous axis state for menu navigation
    function animate() {
      animationFrameId = requestAnimationFrame(animate); // Keep the loop running

      // 1. Update Gamepad State (Handles connect/disconnect and reads fresh data)
      updateGamepadState();

      // 2. Process Input based on Current Screen
      switch (currentScreen) {
        case 'difficulty':
          processDifficultyInput();
          break;
        case 'game':
          if (gameActive) {
            updateCarMovement(); // Handles input internally
            checkCollisions();
            // Animate hearts
            hearts.forEach(heart => {
              if (heart.parent) {
                heart.rotation.y += heart.userData.rotationSpeed || 0.01;
              }
            });
          }
          break;
        case 'gameOver':
          processGameOverInput();
          break;
      }


      // 3. Render Scene (only if in 'game' state and renderer exists)
      if (currentScreen === 'game' && renderer && scene && camera) {
        try {
          renderer.render(scene, camera);
        } catch (error) {
          console.error("Error during rendering:", error);
          endGame(false, "Rendering Error"); // Handle potential render crash
        }
      }

      // Store current axes state for next frame's comparison (menu navigation)
      previousGamepadAxes = {...gamepadAxes};
    }

    // --- Start Setup ---
    window.onload = () => {
      console.log("Window loaded. Setting up initial state.");
      setupInitialScreen(); // Show difficulty selection first
    };

  </script>
</body>

</html>
